#include <iostream>
#include <iomanip>
#include <cstdio>
#include <ctype.h>
#include <cassert>
#include <cstring>
#include "cirMgr.h"
#include "cirGate.h"
#include "util.h"

using namespace std;

/*******************************/
/*   Global variable and enum  */
/*******************************/
CirMgr* cirMgr = 0;
enum CirParseError {
   EXTRA_SPACE,
   MISSING_SPACE,
   ILLEGAL_WSPACE,
   ILLEGAL_NUM,
   ILLEGAL_IDENTIFIER,
   ILLEGAL_SYMBOL_TYPE,
   ILLEGAL_SYMBOL_NAME,
   MISSING_NUM,
   MISSING_IDENTIFIER,
   MISSING_NEWLINE,
   MISSING_DEF,
   CANNOT_INVERTED,
   MAX_LIT_ID,
   REDEF_GATE,
   REDEF_SYMBOLIC_NAME,
   REDEF_CONST,
   NUM_TOO_SMALL,
   NUM_TOO_BIG,

   DUMMY_END
};

/**************************************************************/
/*   class CirMgr member functions for circuit construction   */
/**************************************************************/
bool CirMgr::readCircuit(string &fileOne,string &fileTwo){
	if(one && two)
		clean();
	one = new Circuit;
	two = new Circuit;

	if(!one->read(fileOne,1) || !two->read(fileTwo,2))
		return false;

	assert(one->inputSize() == two->inputSize());
	size_t n=one->inputSize();
	_input.resize(n);
	for(size_t i=0;i<n;++i){
		_input[i].push_back(one->getInput(i));
		_input[i].push_back(two->getInput(i));
	}
	
	return true;

}

/************************/
/*  printing functions  */
/************************/
void CirMgr::printSummary(){
	cout<<"Circuit ONE"<<endl;
	one->printSummary();
	cout<<"\n===========\n"<<endl;

	cout<<"Circuit TWO"<<endl;
	two->printSummary();
	cout<<"\n===========\n"<<endl;

}
void CirMgr::printNetlist(){
	cout<<"CirCuit ONE"<<endl;
	one->printNetlist();
	cout<<endl;

	cout<<"CirCuit TWO"<<endl;
	two->printNetlist();
	cout<<endl;
	return;
}
void CirMgr::printPIs(){
	cout<<"PI"<<endl;
	return;
}
void CirMgr::printPOs(){
	cout<<"PO"<<endl;
	return;
}
void CirMgr::printFECpairs(){
	if(_FECgroup.size()==0){
		cout<<"no FEC pair."<<endl;
		return;
	}
	for(size_t i=0;i<_FECgroup.size();++i){
		cout<<"["<<i<<"] ";
		for(size_t j=0;j<_FECgroup[i].size();++j)
		cout<<" "<<_FECgroup[i][j]->getName()<<"("<<((WireGate*)_FECgroup[i][j])->getCircuitNum()<<")";
		cout<<endl;
	}
}
/*************************/
/*  Simulation Function  */
/*************************/
//void CirMgr::fileSim(){return}
void CirMgr::randomSim(){
	//put all wire into a FECgroup
	if(_FECgroup.size()==0){
		vector<CirGate*> firstGroup;
		getWire(one,firstGroup);
		getWire(two,firstGroup);

		_FECgroup.push_back(firstGroup);
	}
 	//simulation operate
	size_t fail_num=0,max_fail_num=200,fecSize=_FECgroup.size();
	cout<<"MAX_FAIL:"<<max_fail_num<<endl;
	do{
		inputSetValue();
		simulate();
		findFECgroup();
		if(fecSize==_FECgroup.size())
			++fail_num;
		else
			fail_num=0;
		fecSize=_FECgroup.size();
		cout<<_FECgroup.size()<<char(13);
	}while(fail_num!=max_fail_num && fecSize!=0);
	cout<<"FECgroup:"<<_FECgroup.size()<<endl;
}


void CirMgr::getWire(Circuit* circuit,vector<CirGate*> &list){
	for(size_t i=0,n=circuit->dListSize();i<n;++i){
		CirGate* tmp=circuit->getdList(i);
		if(tmp->getType()==Wir){
			if(list.size()==0)
				((WireGate*)tmp)->set_refGate(tmp);
			else
				((WireGate*)tmp)->set_refGate(list[0]);
			list.push_back(tmp);
		}
	}
}

void CirMgr::inputSetValue(){
	for(size_t i=0,n=_input.size();i<n;++i){
		unsigned int value=rand();
		assert(_input[i].size()==2);
		if(!_input[i][0]->setCurSim(value) || !_input[i][1]->setCurSim(value))
			assert(0);
	}
	for(size_t i=0,n=_cut.size();i<n;++i){
		unsigned int value=rand();
		assert(_cut[i].size()>1);
		for(size_t j=0,k=_cut[i].size();j<k;++j)
			if(!_cut[i][j]->setCurSim(value))
				assert(0);
	}
}
void CirMgr::simulate(){
	one->simulate();
	two->simulate();
}

void CirMgr::findFECgroup(){
	vector<vector<CirGate*> >newFEC;
	for(size_t i=0,n=_FECgroup.size();i<n;++i){
		if(_FECgroup[i].size()==2){//only two gates in a pair
			CirGate	*gate1=_FECgroup[i][0],*gate2=_FECgroup[i][1];
			if(gate1->getCurSim()==gate2->getCurSim() || gate1->getCurSim()==~(gate2->getCurSim()))
				newFEC.push_back(_FECgroup[i]);
			else{
				((WireGate*)gate1)->set_refGate(0);
				((WireGate*)gate2)->set_refGate(0);
			}
		}
		else if(_FECgroup[i].size()>2){//more than two gaets */
			HashMap<simKey,CirGate*> hash(getHashSize(_FECgroup[i].size()));
			for(size_t j=0;j<_FECgroup[i].size();++j)
				checkFEC(_FECgroup[i][j],newFEC,hash);
		}
		else
			assert(_FECgroup[i].size()==0);
	}
	_FECgroup.clear();
	for(size_t i=0;i<newFEC.size();++i){
		if(newFEC[i].size()>1){
			((WireGate*)newFEC[i][0])->setFECNum(_FECgroup.size());
			_FECgroup.push_back(newFEC[i]);
		}
		else{
			assert(newFEC[i].size()==1);
			((WireGate*)newFEC[i][0])->set_refGate(0);
		}
	}
}

void CirMgr::checkFEC(CirGate* gate,vector<vector<CirGate*> > &FEC,HashMap<simKey,CirGate*> &hash){
	simKey k(gate->getCurSim());
	CirGate* refGate;
	if(hash.check(k,refGate)){
		assert(FEC.size()>((WireGate*)refGate)->getFECNum());
		FEC[((WireGate*)refGate)->getFECNum()].push_back(gate);
		((WireGate*)gate)->set_refGate((WireGate*)refGate);
	}
	else{
		hash.insert(k,gate);
		((WireGate*)gate)->set_refGate((WireGate*)gate);
		((WireGate*)gate)->setFECNum(FEC.size());

		vector<CirGate*> tmp;
		tmp.push_back(gate);
		FEC.push_back(tmp);
	}
}
/********************/
/*  Check Function  */
/********************/
void CirMgr::CheckEquil()const{
	assert(one->outputSize()==two->outputSize());
	bool equi=true;
	for(size_t i=0,n=one->outputSize();i<n;++i){
		if(	one->getOutput(i)->getCurSim() != two->getOutput(i)->getCurSim() &&
			one->getOutput(i)->getCurSim() != ~(two->getOutput(i)->getCurSim())   
		){
		cout<<"output:"<<i<<" is not equil."<<endl;
		equi=false;
		//return;
		}
	}
	if(equi)
		cout<<"Crcuit equivalent."<<endl;
	else
		cout<<"Circuit not equivalent."<<endl;




}

/********************/
/*  Prove Function  */
/********************/
void CirMgr::satProve(){
	cout<<"proving circuit one..."<<endl;
	sat(one);
	cout<<"proving circuit two..."<<endl;
	sat(two);
}

void CirMgr::sat(Circuit* c){
	for(size_t i=0,n=c->dListSize();i<n;++i){
		if(c->getdList(i)->getType()==Wir){
			WireGate* gate=(WireGate*)c->getdList(i);
			WireGate* ref=gate->get_refGate();
			cout<<gate<<":"<<ref<<endl;
			if(ref!=0 && ref!=gate && !prove(ref,gate,_solver)){
				getInputPattern(_solver);	
				size_t fecNum=ref->getFECNum();
				if(_FECgroup[fecNum].back()!=gate){
					cout<<"update... "<< n-i-1 <<" gate remain to check..."<<endl;
					simulate();
					findFECgroup();
				}
				else
					cout<<"equil"<<endl;
			}
		}
	}
}

bool CirMgr::prove(CirGate* first,CirGate* uncheck,SatSolver*& s){
	cout<<"Proving ("<<first->getName()<<","<<uncheck->getName()<<")";
	Var nVar=s->newVar();
	if(first->Invert()==uncheck->Invert())
		s->addXorCNF(nVar,first->getVar(),false,uncheck->getVar(),false);
	else if(first->Invert()==!(uncheck->Invert()))
		s->addXorCNF(nVar,first->getVar(),false,uncheck->getVar(),true);
	else
		assert(0);
	
	s->assumeRelease();
	s->assumeProperty(nVar,true);
	s->assumeProperty(_true,true);
	s->assumeProperty(_false,false);
	bool result=s->assumpSolve();
	cout<<char(13);
	return !result;
}
void CirMgr::getInputPattern(SatSolver *&s){
	for(size_t i=0;i<_input.size();++i){
		int value=s->getValue(_input[i][0]->getVar());
		((PIGate*)_input[i][0])->setCurSimBit(value);
		((PIGate*)_input[i][1])->setCurSimBit(value);
	}
	for(size_t i=0;i<_cut.size();++i){
		int value=s->getValue(_cut[i][0]->getVar());
		for(size_t j=0;j<_cut[i].size();++j)
			_cut[i][j]->setCurSimBit(value);
	}
}

void CirMgr::genProveModel(bool replace){
	if(!replace && _solver){
		cout<<"solver already exist."<<endl;
		return ;
	}
	if(_solver)
		delete _solver;
	_solver=new SatSolver;
	_solver->initialize();
	_true=_solver->newVar();
	_false=_solver->newVar();
	inputSetVar(_solver);
	one->genProveModel(_solver,_true,_false);
	two->genProveModel(_solver,_true,_false);
}

void CirMgr::inputSetVar(SatSolver *s){
	//input set Var
	cout<<"Input set Var"<<endl;
	for(size_t i=0,n=_input.size();i<n;++i){
		cout<<	"	input ["<<i<<"]...";
		assert(_input[i].size()==2);
		Var v=s->newVar();
		_input[i][0]->setVar(v);
		_input[i][1]->setVar(v);
		cout<<"ok!"<<char(13);
	}
	cout<<endl;
	//cut set Var
	for(size_t i=0,n=_cut.size();i<n;++i){
		assert(_cut[i].size()>0);
		Var v=s->newVar();
		for(size_t j=0;j<_cut[i].size();++j)
			_cut[i][j]->setVar(v);
	}
	cout<<"Input set Var end"<<endl;
}
/*********************/
/*  Helper Function  */
/*********************/
/*****************************/
/*  clean and init function  */ 
/*****************************/
void CirMgr::init(){
	one=0;
	two=0;
	_solver=0;
	srand(0);
	//srand(time(0));
}

void CirMgr::clean(){
	delete one;
	delete two;
	init();
}
